# 【問題】ミニコンピュータ
#あなたの友人である K 氏は電子工作が大好きです。
# 彼は毎晩試行錯誤を重ね、最近ついにコンピュータのミニチュア版を開発することに成功しました。

# 彼のコンピュータはちょうど 2 つの変数を持っており、どちらの変数も 0 で初期化されています。
# また、彼のコンピュータは次の 3 種類の命令を実行することができます。

# ・SET i a : 変数 i に値 a を代入する (i = 1, 2)
# ・ADD a :「変数 1 の値 + a」を計算し、計算結果を変数 2 に代入する
# ・SUB a :「変数 1 の値 - a」を計算し、計算結果を変数 2 に代入する

# 彼は、自分のコンピュータが正しく動いているかどうかチェックしてほしいと依頼してきました。
# コンピュータが完成して嬉しそうな彼の頼みを断るわけにはいきません。

# 自分の回答
order = []
a = 0
b = 0

num = gets.to_i
num.times { order << gets.chomp.split }

order.each do |n|
  if n[0] == "SET"
    if n[1] == "1"
      a = n[2].to_i
    elsif n[1] == "2"
      b = n[2].to_i
    end
  elsif n[0] == "ADD"
    b = a + n[1].to_i
  elsif n[0] == "SUB"
    b = a - n[1].to_i
  end
end

puts "#{a} #{b}"



# 【問題】枠で囲む
# あなたは友人に向けてメールを送ろうとしています。
# ただメールを送るだけではつまらないので、文字列を装飾して送ることにしました。
# 送りたい文字列の周囲を "+" で枠のように囲んで装飾します。

# このような処理を手作業で行いたくないため、プログラムで装飾しようとしています。
# この "+" の枠で囲む装飾をするプログラムを書いてください。

# 入力例 1 では "Hello" という文字列を送ります。
# この文字を枠で囲み装飾すると、以下のようになります。
# +++++++
# +Hello+
# +++++++

# str = gets.chomp

# def decoration(str)
#   dec = "+" * (str.length + 2)
#   puts dec
#   puts "+#{str}+"
#   puts dec
# end

# decoration(str)

# 【問題】カード並べ
# フライト中に退屈してしまったあなたは、持っているトランプを使用した簡単な遊びを考えました。

# この遊びでは 1 から 9 までの数字のカードのみを 4 枚使用します。
# ただし、この 4 枚の中で同じ数値のカードが重複する事もあります。
# ルールは以下の通りです。

# 4 枚のカードを横に並べます。
# 左から 2 枚のカード、右から 2 枚のカードをそれぞれ 2 ケタの整数とみなし、和を計算します。
# あらゆる並べ方を試し、和の最大値（最大スコア）を求めます。

# カード 4 枚に書かれた数が与えられるので、最大スコアを出力してください。
# 入力例 1 の 2, 9, 3, 8 の 4 枚を使う場合、以下の 12 通りの和の最大値 175 が最大スコアとなります。

# カードの 4 枚の並べ方は 4! = 24 通り存在しますが、足し算は順序に依存しないため、12 通りのみ考慮すればよいことに注意してください。
# たとえば、9, 2, 3, 8 の順で並べた場合のスコアは 92 + 38 = 130 となります。

# ・92 + 38 = 130
# ・92 + 83 = 175
# ・93 + 28 = 121
# ・93 + 82 = 175
# ・98 + 23 = 121
# ・98 + 32 = 130
# ・39 + 28 = 67
# ・38 + 29 = 67
# ・82 + 39 = 121
# ・89 + 23 = 112
# ・89 + 32 = 121
# ・83 + 29 = 112

# 自分の回答（出力結果は正解だけど、ロジック部分が問題の意図するやり方と異なる）
# num1, num2, num3, num4 = gets.split.map(&:to_i)
# numbers = [num1, num2, num3, num4]

# def maximum_sum(numbers)
#   max_nums = numbers.max(2)
#   min_nums = numbers.min(2)

#   result_number = []
#   max_nums.each_with_index do |n, i|
#     result_number << (n.to_s + min_nums[i].to_s).to_i
#   end
#   puts result_number.sum
# end

# maximum_sum(numbers)


# 【問題】ポイント払い

# N市に住んでいるあなたは、普段の移動手段は全て Nバスを使います。Nバスでは nikaという IC カードを乗車券として使うことができます。
# 事前に nika にチャージをすることで利用できます。

# バスの運賃支払に nika のカード残額を使うと、運賃の 10 % が nika ポイントとしてたまります。

# バスを降車する時に、支払う運賃以上のポイントがある場合は、ポイントが優先的に運賃の支払いに使われます。
# ただし、1 ポイントは 1 円になります。ただし、ポイントで運賃を支払った場合、新たなポイントは発生しません。


# あなたは、カード残金とポイントをどれくらい使ったか知るためのプログラムを書くことにしました。
# あなたには、最初にチャージする現金と、バスを利用した時にかかった料金のリストが与えられるので、毎回の降車時に残っているお金とポイントを出力してください。
# ただし、途中でカード残高とポイントの両方が運賃を下回ることはありません。
# 入力例 1 は以下のようになります。

# 自分の回答（一応正解）
# charge, num = gets.split.map(&:to_i)
# fare = []
# point = 0

# num.times do |i|
#   fare << gets.to_i
# end

# fare.each do |f|
#   if point < f
#     charge -= f
#     point += ( f * 0.1 ).floor
#   else
#     point -= f
#   end
#   puts "#{charge} #{point}"
# end


# 【問題】完全数とほぼ完全数
# N を 2 以上の整数とし、N の約数のうち N 自身を除いたものの和を S とします。
# このとき
# ・N = S となるような N を完全数
# ・|N-S| = 1 となるような N をほぼ完全数

# と言うことにしましょう。ここで、|N-S| は N-S の絶対値を意味します。

# たとえば、N = 28 のとき、28 の約数は 1, 2, 4, 7, 14, 28 なので、S = 1+2+4+7+14 = 28 となります。従って、28 は完全数です。
# また、N = 16 のときには S = 1+2+4+8 = 15 となるので、16 はほぼ完全数です。

# 入力された整数が完全数かほぼ完全数かそのいずれでもないかを判定するプログラムを作成してください。

# 自分の回答（一応正解）
# num = gets.to_i
# num_ary = []

# num.times do |i|
#   num_ary << gets.to_i
# end

# num_ary.each do |n|
#   result = []
#   (1..n - 1).each { |i| result << i if n % i == 0 }

#   if result.sum == n
#     puts "perfect"
#   elsif result.sum == n - 1
#     puts "nearly"
#   else
#     puts "neither"
#   end
# end




# 【問題】何日後になるか

# あなたはカレンダーのプログラムを作成しています。そこで N 週間後が何日後かを表示する機能を作ることにしました。
# N 週間後は何日後かを計算してください。

# 例えば
# 6
# と入力された 1 週間は 7 日間なので 6 × 7
# 42
# と出力してください。





# 【問題】日付の表記
# 日本では日付を 2020年10月31日 と言ったように年、月、日の順に記載します。
# 一方アメリカなどでは 月、日、年の順で 10/31/22020 などと記載します。

# 日本で一般的な順の年、月、日の順に日付が改行区切りで与えられるのでアメリカなどで使われている形式で月/日/年の形式で出力してください。

# 例えば
# 2020
# 10
# 31
# と入力された場合
# 10/31/2020

# 自分の回答（正解）
# Y = gets.to_i
# M = gets.to_i
# D = gets.to_i
# puts "#{M}/#{D}/#{Y}"



# 【問題】　アドレス調査（不正解）
# あなたはあるソフトウェアの開発でIPアドレスを入力してもらう機能の一部を開発しています。
# 入力は手入力で「.」と「数字」で構成された長さNの文字列が入力されます。

# 入力されているIPアドレスが書式に合っているか判定して、合っていればTrue、
# 違っていればFalseと標準出力で出力するプログラムを作成してください。

# 判別すべきIPアドレスはIPv4で定義された範囲のIPアドレスとします。書式は以下のようになります。

# .で区切られた10進数の4つの数で表されます。
# 数の範囲は0から255までとします。
# 例:
# 100.23.103.20
# 123.11.22.33
# 14.33.103.20
# 102.233.13.2

# 自分の回答（不正解）
# ip = gets.to_s
# ip_address = gets.to_s
# ip_array = ip_address.split('.')
# result = ""
# ip_array.each do |num|
#   if ip_array.length != 4
#     result = "False"
#     break
#   elsif num.to_i > 255 || num.to_i < 0
#     result =  "False"
#     break
#   else
#     result = "True"
#   end
# end
# puts result



# 【問題】　N倍の文字列
# 正の整数 N が標準入力から入力されるので、N 個の「*」を繋げた文字列を出力するプログラムを作成しましょう。

# 例えば N = 3の場合
# ***
# のように出力してください。

# num = gets.to_i
# puts "*" * num


# 2つの値をスペースを入れて入力させる場合
# input, input2 = gets.split
# puts  input.to_i + input2.to_i

# Leet文字列への変換
# input = gets.chomp.chars
# input.each {|w|
#   case w
#   when 'A'
#     print '4'
#   when 'E'
#     print '3'
#   when 'G'
#     print '6'
#   when 'I'
#     print '1'
#   when 'O'
#     print '0'
#   when 'S'
#     print '5'
#   when 'Z'
#     print '2'
#   else
#     print w
#   end
# }

# Leet文字列への変換　その他
# TRANSFORM_TABLE = {
#   'A' => '4',
#   'B' => '8',
#   'C' => '［',
#   'D' => 'T)',
#   'E' => '3'
# }

# puts gets.gsub(/[A-E]/, TRANSFORM_TABLE)
